<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Portfolio</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@100..900&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="style.css" />
  <link href="https://unpkg.com/boxicons@2.1.4/css/boxicons.min.css" rel="stylesheet" />
  <script src="https://kit.fontawesome.com/45d6cd657c.js" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/ScrollTrigger.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/CustomEase.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/EasePack.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/MotionPathPlugin.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/PixiPlugin.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/TextPlugin.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/Draggable.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/Observer.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/ScrollToPlugin.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/SplitText.min.js"></script>
</head>

<body>
  <header>
    <a href="#home" class="logo">Aryan</a>
    <nav class="navbar" id="navbar">
      <a href="#home">Home</a>
      <a href="#about">About</a>
      <a href="#projects">Projects</a>
      <a href="#contact">Contact</a>
    </nav>
    <div class="mobile-menu-btn" id="mobile-menu-btn">
      <span></span>
      <span></span>
      <span></span>
    </div>
    <div class="icons">
      <a href="https://github.com/1102Aryan"><i class="bx bxl-github"></i></a>
      <a href="https://www.linkedin.com/in/aryan-sunil-532920287/"><i class="bx bxl-linkedin"></i></a>
    </div>
  </header>

  <div class="container">
    <section class="home" id="home">
      <div class="glass-section">
        <div class="homecontent">
          <h1>Hello, my name is <span>Aryan</span></h1>
          <p>Experience in Java, C#, Python and C. Check out my projects and contact me for more info.</p>
        </div>
      </div>
    </section>

    <section class="about" id="about">
      <div class="glass-section">
        <div class="aboutcontent">
          <h1>More about <span>me</span></h1>
          <p>Second Year Computer Science student at University of Nottingham.</p>
        </div>
      </div>
    </section>

    <section class="projects" id="projects">
      <div class="glass-section">
        <div class="projectscontent">
          <h1><span>Projects</span></h1>
          <div class="projectbox">
            <div class="projectcard">
              <img src="resources/learnMalayalam.png" alt="Learn Malayalam App">
              <h2>Learn Malayalam App</h2>
              <p>The goal of the project was to enhance learning and provide an enjoyable experience to learning the
                language Malayalam.</p>
              <a href="https://github.com/1102Aryan/LearnMalayalam" class="btn">View</a>
            </div>
            <div class="projectcard">
              <img src="resources/drawing.png" alt="Learn Malayalam App">
              <h2>Video To Album Cover</h2>
              <p>Video To Album Cover is an extension for Youtube Music that removes pesky videos and shows the music
                cover instead to provide less distractions.</p>
              <a href="https://github.com/1102Aryan/VideoToAlbumCover" class="btn">View</a>
            </div>
          </div>
        </div>
      </div>
    </section>

    <section class="contact" id="contact">
      <div class="glass-section">
        <h1>You can <span>Contact</span> me here!</h1>
        <form action="https://api.web3forms.com/submit" method="POST">
          <div class="input-group">
            <div class="input-box">
              <input type="hidden" name="access_key" value="ac21949b-e1a9-49bd-8312-564185af18eb">
              <input type="text" name="name" placeholder="Name" required>
              <input type="email" name="email" placeholder="Email" required>
            </div>
            <div class="input-box">
              <input type="text" name="subject" placeholder="Subject" required>
            </div>
            <div class="input-group-2">
              <textarea name="message" placeholder="Your message" rows="8" required></textarea>
              <input type="submit" value="Send Message" class="btn">
            </div>
          </div>
        </form>
      </div>
    </section>
  </div>

  <div class="nav-dots">
    <div class="nav-dot active" data-section="0"></div>
    <div class="nav-dot" data-section="1"></div>
    <div class="nav-dot" data-section="2"></div>
    <div class="nav-dot" data-section="3"></div>
  </div>

  <div class="scroll-indicator">
    <div>Scroll horizontally to explore</div>
    <div class="scroll-arrow">â†’</div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', function () {
      const container = document.querySelector('.container');
      const navLinks = document.querySelectorAll('.navbar a');
      const navDots = document.querySelectorAll('.nav-dot');
      const sections = document.querySelectorAll('section');
      const scrollIndicator = document.querySelector('.scroll-indicator');
      const header = document.querySelector('header');

      let isNavigating = false;
      let currentSection = 0;
      let targetSection = 0;
      let animationId = null;

      // Apple-style easing function
      function easeInOutCubic(t) {
        return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
      }

      // Smooth animation function
      function animateToSection(targetIndex, duration = 1200) {
        if (isNavigating || targetIndex === currentSection) return;

        isNavigating = true;
        targetSection = targetIndex;

        const startPosition = currentSection * window.innerWidth;
        const endPosition = targetIndex * window.innerWidth;
        const distance = endPosition - startPosition;

        let startTime = null;

        // Pre-animate sections for smooth entrance
        sections.forEach((section, index) => {
          const glassSection = section.querySelector('.glass-section');
          if (index === targetIndex) {
            // Prepare target section
            glassSection.style.transform = 'translateY(30px) scale(0.95)';
            glassSection.style.opacity = '0.7';
          } else if (index === currentSection) {
            // Prepare current section to exit
            glassSection.style.transform = 'translateY(0) scale(1)';
            glassSection.style.opacity = '1';
          }
        });

        function animate(timestamp) {
          if (startTime === null) startTime = timestamp;
          const elapsed = timestamp - startTime;
          const progress = Math.min(elapsed / duration, 1);
          const easedProgress = easeInOutCubic(progress);

          // Main container movement
          const currentPosition = startPosition + (distance * easedProgress);
          container.style.transform = `translateX(-${currentPosition}px)`;

          // Parallax effect on sections
          sections.forEach((section, index) => {
            const glassSection = section.querySelector('.glass-section');
            const relativeProgress = progress;

            if (index === currentSection) {
              // Exit animation for current section
              const exitOpacity = 1 - (relativeProgress * 0.4);
              const exitY = relativeProgress * -20;
              const exitScale = 1 - (relativeProgress * 0.02);
              glassSection.style.transform = `translateY(${exitY}px) scale(${exitScale})`;
              glassSection.style.opacity = exitOpacity;
            } else if (index === targetIndex) {
              // Enter animation for target section
              const enterOpacity = 0.7 + (relativeProgress * 0.3);
              const enterY = 30 - (relativeProgress * 30);
              const enterScale = 0.95 + (relativeProgress * 0.05);
              glassSection.style.transform = `translateY(${enterY}px) scale(${enterScale})`;
              glassSection.style.opacity = enterOpacity;
            }
          });

          // Header blur effect during navigation
          const blurAmount = Math.sin(progress * Math.PI) * 2;
          header.style.backdropFilter = `blur(${25 + blurAmount}px)`;

          // Navigation dots animation
          navDots.forEach((dot, index) => {
            if (index === targetIndex) {
              const scale = 1 + (Math.sin(progress * Math.PI) * 0.2);
              dot.style.transform = `scale(${scale})`;
            }
          });

          if (progress < 1) {
            animationId = requestAnimationFrame(animate);
          } else {
            // Animation complete
            currentSection = targetIndex;
            isNavigating = false;

            // Reset transforms
            sections.forEach((section, index) => {
              const glassSection = section.querySelector('.glass-section');
              glassSection.style.transform = index === currentSection ?
                'translateY(0) scale(1)' : 'translateY(50px) scale(0.95)';
              glassSection.style.opacity = index === currentSection ? '1' : '0';
            });

            header.style.backdropFilter = 'blur(25px)';
            navDots.forEach(dot => dot.style.transform = 'scale(1)');

            updateActiveStates(currentSection);

            // Hide/show scroll indicator
            scrollIndicator.style.opacity = currentSection > 0 ? '0' : '0.7';
          }
        }

        // Cancel any existing animation
        if (animationId) cancelAnimationFrame(animationId);
        animationId = requestAnimationFrame(animate);
      }

      // Update active navigation states with micro-animations
      function updateActiveStates(index) {
        navLinks.forEach((link, i) => {
          const isActive = i === index;
          link.classList.toggle('active', isActive);
          if (isActive) {
            link.style.transform = 'translateY(-2px) scale(1.02)';
          } else {
            link.style.transform = 'translateY(0) scale(1)';
          }
        });

        navDots.forEach((dot, i) => {
          const isActive = i === index;
          dot.classList.toggle('active', isActive);
        });
      }

      // Enhanced mouse wheel with momentum and threshold control
      let wheelVelocity = 0;
      let wheelTimeout;
      let lastWheelTime = 0;
      let wheelDebounce = false;
      let wheelAccumulator = 0;

      window.addEventListener('wheel', function (e) {
        if (isNavigating || wheelDebounce) return;

        const deltaY = e.deltaY;
        const deltaX = e.deltaX;
        const now = Date.now();

        // Determine scroll direction (prioritize vertical scroll)
        let scrollDirection = 0;
        let scrollMagnitude = 0;

        if (Math.abs(deltaY) > Math.abs(deltaX)) {
          scrollDirection = deltaY > 0 ? 1 : -1;
          scrollMagnitude = Math.abs(deltaY);
        } else if (Math.abs(deltaX) > 10) {
          scrollDirection = deltaX > 0 ? 1 : -1;
          scrollMagnitude = Math.abs(deltaX);
        }

        if (scrollDirection === 0) return;

        // Accumulate scroll delta over time
        wheelAccumulator += scrollMagnitude * scrollDirection;

        clearTimeout(wheelTimeout);

        // Set threshold for navigation (adjust these values to control sensitivity)
        const SCROLL_THRESHOLD = 50; // Increase this number to make it less sensitive
        const TIME_WINDOW = 30; // Time window to accumulate scroll events

        wheelTimeout = setTimeout(() => {
          // Check if accumulated scroll exceeds threshold
          if (Math.abs(wheelAccumulator) > SCROLL_THRESHOLD) {
            if (wheelAccumulator > 0 && currentSection < sections.length - 1) {
              wheelDebounce = true;
              animateToSection(currentSection + 1);
              setTimeout(() => { wheelDebounce = false; }, 1000);
            } else if (wheelAccumulator < 0 && currentSection > 0) {
              wheelDebounce = true;
              animateToSection(currentSection - 1);
              setTimeout(() => { wheelDebounce = false; }, 1000);
            }
          }

          // Reset accumulator
          wheelAccumulator = 0;
        }, TIME_WINDOW);

        e.preventDefault();
      }, { passive: false });

      // Enhanced touch with momentum and rubber band effect
      let startX = 0, startY = 0, currentX = 0;
      let isSwipeActive = false;
      let swipeVelocity = 0;
      let lastTouchTime = 0;

      container.addEventListener('touchstart', function (e) {
        if (isNavigating) return;

        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
        currentX = startX;
        isSwipeActive = true;
        swipeVelocity = 0;
        lastTouchTime = Date.now();
      });

      container.addEventListener('touchmove', function (e) {
        if (!isSwipeActive || isNavigating) return;

        e.preventDefault();
        currentX = e.touches[0].clientX;
        const deltaX = currentX - startX;
        const now = Date.now();
        const timeDelta = now - lastTouchTime;

        if (timeDelta > 0) {
          swipeVelocity = deltaX / timeDelta;
        }

        // Rubber band effect at edges
        const currentPos = currentSection * window.innerWidth;
        let resistance = 1;

        if ((currentSection === 0 && deltaX > 0) ||
          (currentSection === sections.length - 1 && deltaX < 0)) {
          resistance = 0.3;
        }

        container.style.transform = `translateX(-${currentPos - (deltaX * resistance)}px)`;
        lastTouchTime = now;
      });

      container.addEventListener('touchend', function (e) {
        if (!isSwipeActive) return;

        const deltaX = currentX - startX;
        const threshold = window.innerWidth * 0.2;

        // Reset container position
        container.style.transform = `translateX(-${currentSection * window.innerWidth}px)`;

        // Determine navigation based on swipe distance and velocity
        if (Math.abs(deltaX) > threshold || Math.abs(swipeVelocity) > 0.5) {
          if (deltaX > 0 && currentSection > 0) {
            animateToSection(currentSection - 1);
          } else if (deltaX < 0 && currentSection < sections.length - 1) {
            animateToSection(currentSection + 1);
          }
        }

        isSwipeActive = false;
      });

      // Navigation clicks with haptic-like feedback
      navLinks.forEach((link, index) => {
        link.addEventListener('click', function (e) {
          e.preventDefault();
          e.stopPropagation();

          // Visual feedback
          link.style.transform = 'translateY(-2px) scale(0.98)';
          setTimeout(() => {
            link.style.transform = 'translateY(-2px) scale(1.02)';
          }, 150);

          animateToSection(index, 1000);
        });

        // Hover effects
        link.addEventListener('mouseenter', () => {
          if (!link.classList.contains('active')) {
            link.style.transform = 'translateY(-1px) scale(1.01)';
          }
        });

        link.addEventListener('mouseleave', () => {
          if (!link.classList.contains('active')) {
            link.style.transform = 'translateY(0) scale(1)';
          }
        });
      });

      // Nav dots with pulse animation
      navDots.forEach((dot, index) => {
        dot.addEventListener('click', function (e) {
          e.preventDefault();
          e.stopPropagation();
          animateToSection(index, 1000);
        });
      });

      // Keyboard navigation
      document.addEventListener('keydown', function (e) {
        if (isNavigating) return;

        if (e.key === 'ArrowLeft' && currentSection > 0) {
          animateToSection(currentSection - 1);
        } else if (e.key === 'ArrowRight' && currentSection < sections.length - 1) {
          animateToSection(currentSection + 1);
        }
      });

      // Mobile menu functionality
      const mobileMenuBtn = document.getElementById('mobile-menu-btn');
      const navbar = document.getElementById('navbar');

      mobileMenuBtn.addEventListener('click', () => {
        mobileMenuBtn.classList.toggle('active');
        navbar.classList.toggle('active');
      });

      navLinks.forEach(link => {
        link.addEventListener('click', () => {
          mobileMenuBtn.classList.remove('active');
          navbar.classList.remove('active');
        });
      });

      document.addEventListener('click', (e) => {
        if (!navbar.contains(e.target) && !mobileMenuBtn.contains(e.target)) {
          mobileMenuBtn.classList.remove('active');
          navbar.classList.remove('active');
        }
      });

      // Initialize with staggered entrance animation
      setTimeout(() => {
        sections.forEach((section, index) => {
          const glassSection = section.querySelector('.glass-section');
          if (index === 0) {
            glassSection.style.opacity = '0';
            glassSection.style.transform = 'translateY(50px) scale(0.95)';

            setTimeout(() => {
              glassSection.style.transition = 'all 1s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
              glassSection.style.opacity = '1';
              glassSection.style.transform = 'translateY(0) scale(1)';
            }, 100);
          } else {
            glassSection.style.opacity = '0';
            glassSection.style.transform = 'translateY(50px) scale(0.95)';
          }
        });

        updateActiveStates(0);
      }, 300);
    });
  </script>
</body>

</html>